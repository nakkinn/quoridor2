# DESIGN.md - コリドール設計書

## 1. 目的

コリドールをローカル動作のウェブアプリとして実装する。
将来的なCPUプレイヤー実装を見据え、アルゴリズム検討が容易なデータ構造と環境を構築する。

---

## 2. フェーズ1の目標（本フェーズ）

- ゲームがウェブブラウザで正常に動作することを確認
- 2人が交互に操作できる対戦機能
- 盤面を自由に編集できるモード（CPU開発用）
- 盤面状態のエクスポート/インポート機能

---

## 3. 機能仕様

### 3.1 対戦モード

- 2人のプレイヤーが1台の端末で交互に操作
- 手番表示
- 勝利判定と結果表示
- 合法手のハイライト表示

### 3.2 盤面編集モード

- 任意のマスにプレイヤー駒を配置
- 任意の位置に壁を配置/削除
- 手番の切り替え
- 残り壁数の設定
- 編集モードと対戦モードの切り替え

### 3.3 エクスポート/インポート

- 現在の盤面状態を文字列として出力
- 文字列から盤面状態を復元
- クリップボードへのコピー/貼り付け対応

---

## 4. データ構造設計

### 4.1 座標系

2つの座標系を使用する：

```
■ プレイヤー座標系（9×9）
  - x, y: 0〜8
  - 左上が (0, 0)、右下が (8, 8)
  - プレイヤー1のゴール: y = 8
  - プレイヤー2のゴール: y = 0

■ 壁座標系（8×8）
  - x, y: 0〜7
  - マスとマスの間の交点を表す
  - 壁座標 (wx, wy) は、プレイヤー座標 (wx, wy) と (wx+1, wy+1) の間の交点
```

図示：
```
  0   1   2   3   ...  8    ← プレイヤーx座標
  □ ┃ □ ┃ □ ┃ □  ...  □
    0   1   2   3  ...      ← 壁x座標
  ━━━━━━━━━━━━━━━
  □ ┃ □ ┃ □ ┃ □  ...  □
```

### 4.2 壁の表現（8×8配列）

```javascript
// walls[wy][wx] の値:
//   0 = 壁なし
//   1 = 縦壁 (vertical)    ┃
//   2 = 横壁 (horizontal)  ━
walls: Array(8).fill(null).map(() => Array(8).fill(0))
```

壁は2マス分の長さを持つため、配置時に隣接チェックが必要：
- 縦壁 (wx, wy): (wx, wy-1) と (wx, wy+1) に縦壁があってはならない
- 横壁 (wx, wy): (wx-1, wy) と (wx+1, wy) に横壁があってはならない

### 4.3 ゲーム状態（GameState）

```javascript
const gameState = {
  players: [
    { x: 4, y: 0, wallsLeft: 10 },  // プレイヤー1（上から開始、中央）
    { x: 4, y: 8, wallsLeft: 10 }   // プレイヤー2（下から開始、中央）
  ],
  walls: Array(8).fill(null).map(() => Array(8).fill(0)),
  currentPlayer: 0,  // 0 or 1
  history: []        // 着手履歴（undo用）
};
```

### 4.4 着手の表現

```javascript
// 移動（プレイヤー座標系）
{ type: 'move', x: 4, y: 1 }

// 壁配置（壁座標系 + 向き）
{ type: 'wall', x: 3, y: 2, dir: 'V' }  // 縦壁
{ type: 'wall', x: 5, y: 4, dir: 'H' }  // 横壁
```

### 4.5 壁による移動ブロック判定

プレイヤーが (px, py) から隣接マスへ移動する際の壁チェック：

```javascript
// 右へ移動 (px, py) → (px+1, py)
//   壁座標 (px, py-1) または (px, py) に縦壁があればブロック
function isBlockedRight(walls, px, py) {
  if (py > 0 && walls[py-1][px] === 1) return true;
  if (py < 8 && walls[py][px] === 1) return true;
  return false;
}

// 下へ移動 (px, py) → (px, py+1)
//   壁座標 (px-1, py) または (px, py) に横壁があればブロック
function isBlockedDown(walls, px, py) {
  if (px > 0 && walls[py][px-1] === 2) return true;
  if (px < 8 && walls[py][px] === 2) return true;
  return false;
}
```

### 4.6 エクスポート形式

```
形式: "p1x,p1y,w1;p2x,p2y,w2;turn;壁データ"
壁データ: "wx,wy,dir" をセミコロン区切り（dir: V=縦, H=横）

例: "4,0,10;4,8,10;0;3,2,V;5,4,H"
- P1: (4,0)、残り壁10
- P2: (4,8)、残り壁10
- 手番: 0（P1）
- 壁: (3,2)に縦壁、(5,4)に横壁
```

---

## 5. CPU実装への考慮

### 5.1 状態のイミュータブル性

- `gameState` の変更は常に新しいオブジェクトを生成
- 8×8配列は `walls.map(row => [...row])` で高速に複製可能

### 5.2 合法手生成

```javascript
function getLegalMoves(gameState) {
  const moves = getValidMoves(gameState);  // 移動可能なマス
  const walls = getValidWalls(gameState);  // 配置可能な壁
  return [...moves, ...walls];
}

// 移動: 最大4方向 + ジャンプ + 斜め
// 壁: 最大 8×8×2 = 128 箇所（実際は制約で減る）
```

### 5.3 評価関数用のユーティリティ

```javascript
// BFSでゴールまでの最短距離を計算
function getShortestPath(gameState, playerIndex) {
  const goal = playerIndex === 0 ? 8 : 0;  // P1→y=8, P2→y=0
  // BFS実装
}

// 状態の複製
function cloneState(gameState) {
  return {
    players: gameState.players.map(p => ({...p})),
    walls: gameState.walls.map(row => [...row]),
    currentPlayer: gameState.currentPlayer,
    history: [...gameState.history]
  };
}
```

---

## 6. UI設計

### 6.1 画面構成

```
+---------------------------+---------------------------+
|  手番: プレイヤー1        |                           |
|  残り壁: P1=10  P2=10     |  内部状態（常時表示）     |
+---------------------------+  - JSON形式               |
|                           |  - コピー/ペースト可能    |
|      9×9 盤面表示         |  - 整形表示も併記         |
|                           |                           |
+---------------------------+---------------------------+
| [編集モード] [リセット]   |
+---------------------------+
```

### 6.2 操作方法（PC・マウス前提）

#### 6.2.1 対戦モード

**手番表示**
- 現在の手番プレイヤーを明示
- 手番プレイヤーの駒に黒縁を描画

**モード切り替え**
- 右クリックで「移動モード」と「壁設置モード」を切り替え
- 移動マーカーは両モードで常に表示

**駒移動（移動モード時）**
- 手番プレイヤーの移動可能マスにマーカーを表示
- カーソルがマーカーに近づくとマーカーが拡大
- 左クリックで移動確定

**壁配置（壁設置モード時）**
- カーソル位置に最も近い設置可能な壁を影（プレビュー）で表示
- 設置不可な壁の影は表示しない
- マウスホイールで壁の向きを切り替え（初期: 縦壁）
- 左クリックで壁配置確定

**勝利時**
- 勝者を表示
- 自動的に編集モードへ移行

#### 6.2.2 編集モード

**モード切り替え**
- 右クリックで「移動モード」と「壁設置モード」を切り替え

**駒移動（移動モード時）**
- プレイヤー駒をドラッグして任意のマスに配置
- 他の駒と同じ位置には置けない

**壁配置（壁設置モード時）**
- カーソルを既存の壁に近づけると壁の色が変わる
- その状態でクリックすると壁を削除
- 壁がない場所でクリックすると壁を配置
- 壁が重なる配置は不可（隣接する同方向の壁との干渉チェック）
- ゴール不可能な配置は許可（経路保証チェックなし）
- マウスホイールで壁の向きを切り替え

**その他**
- 対戦モードへの切り替え

### 6.3 内部状態表示

- 画面に常時表示
- 現在のゲーム状態をエクスポート形式で表示
- 整形（インデント・改行付き）形式も併記
- コピーボタンでクリップボードにコピー
- テキストエリアに貼り付けて「反映」ボタンでインポート
- 無効なデータの場合: アラート表示、元のデータに戻す

### 6.4 その他

- 壁は1色（どちらのプレイヤーが置いたか区別しない）
- 操作方法のヘルプは不要
- リセットボタン: 初期状態に戻す

---

## 7. ファイル構成（予定）

```
ver2/
├── index.html      # エントリーポイント
├── style.css       # スタイル
├── sketch.js       # p5.js メイン（描画・入力）
├── game.js         # ゲームロジック
├── board.js        # 盤面操作・合法手生成
├── export.js       # エクスポート/インポート
├── CLAUDE.md       # Claude Code向けガイド
├── DESIGN.md       # 本設計書
└── game_rule.md    # ゲームルール
```

---

## 8. 今後の拡張（フェーズ2以降）

- CPUプレイヤーの実装
  - ミニマックス法 / アルファベータ枝刈り
  - モンテカルロ木探索
- 対戦履歴の保存・再生
- オンライン対戦（WebSocket等）
